COMPLETE ASSEMBLER PROGRAMMING COURSE IN TWO DISKS

BY FABIO CIUCCI - 1994/95

For all those who have tried to learn how to create demos or games that exploit the Amiga hardware directly, but have never succeeded because the books were written in an abstract and convoluted manner and the example sources, the listings that is, were poorly commented or too difficult, or for those who have never tried and wonder how it's done.

I must thank and greet all those who materially or morally contributed to the realization of these two disks, in particular:

Luca Forlizzi (The Dark Coder)
Andrea Fasce (Executor/RAM JAM)
Sirio Zuelli (PROXIMA DESIGN)
Alberto Longo (VIRTUAL DREAMS)

As well as those who tested the lessons to see if they understood or not:

Andrea Scarafoni, Federico "GONZO" Stango, and others.

Finally, I must greet my girlfriend, Kety, who has committed to keeping me away from the computer as much as possible.

In my career as a hobbyist programmer, I can boast the creation of some demos/intros for BBS, for example, "AMILINK.EXE", for the AmigaLink database, or for clubs, such as the one for the new "Amiga Expert Team". My major "works" are my first demo for the AGA chipset, "WORLD OF MANGA", which was also published in some magazines, and "NAOS", which I programmed for the NOVA ACIES group.

I must clarify that it would be good to know at least a little about DOS before starting to read my course, if only to know how to save the listings! You should have found a manual with the Amiga...
Anyway, briefly, on disks (both Hard and Floppy), data is stored in "files", which are a series of numbers one after the other, which together can form graphic, musical, executable, listed files, etc.
Note that a blank disk must be FORMATTED before it can be used, otherwise it is impossible to write on it.
Once formatted, any file can be saved on it, whether graphics programs with graphics, texts (like this one you're reading) or anything else.
A file can be copied from one disk to another, it can be deleted, or its name can be changed, etc. Many files can be stored on a disk, until the 880Kb or so are filled, maybe with 2 files of 400Kb or with about thirty smaller files. Note that within a disk, to keep things tidy, various "subdirectories" can be created, that is, smaller "drawers" where files can be placed.
For example, you can create the subdirs DRAWINGS and TEXTS, where you will respectively copy or save images and letters for your girlfriend, so as not to put drawings and texts together loosely in the main directory.
It's like the disk is a wardrobe, and the subdirs are drawers of this wardrobe. Since you can create subdirs within subdirs, each of these drawers can contain loose files or "boxes" with files or other smaller "boxes" inside. So a system similar to that of furniture!
To perform operations between files, you can use the CLI/SHELL, where you need to write commands like:

Dir         = Lists the files and subdirs contained on a disk
Copy        = Copies files
Delete      = Deletes a file (BE CAREFUL WHEN USING THIS!!!)
Makedir     = Creates a "drawer" (or subdir)

Or you can use the mouse from WorkBench, where files are "depicted" as icons and subdirs as drawers.
Note that the internal drive is called "df0:", the external ones "df1:", "df2:" etc. The hard disk is usually called "Dh0:" (or "Hd0:").
A faster system is to use utilities like DiskMaster or DirOpus.
So when you have written some listing, you should save it on a formatted disk, or on the Hard Disk in a subdir.
Another thing to know is how to make a "autoboot" disk, i.e., one that starts automatically when inserted into the drive at startup or after a reset.
Let's suppose we've saved our EXECUTABLE program on a disk, with the name "myprogram". We need to create a subdirectory "S", where we'll save a text file named "startup-sequence", in which the name of the program to be loaded automatically is written:

myprogram

The startup-sequence can be written (edited) with the program you're currently using, which also serves as a text editor. One last thing, we need to "install" the disk in question, by typing the command from cli/shell:

Install df0:

Or "install df1:" if you insert the disk into the external drive.

Having said that, we can continue with the notes.

NOTE: If you want to install the course on the hard disk, remember to copy the file "TRASH'M-ONE16.pref" from the S: directory of the course disk to your S: directory.

NOTE2: If you want to print the listings, consider that they are compressed with PowerPacker, so you need the PowerPacker Patcher, the one used in this course. (the file is called "PP" in the "C" directory).
To install it, just have the "powerpacker.library" in LIBS: and execute the "PP" command. The listings will be automatically decompressed upon loading.

In this course, various programming topics will be covered, such as the COPPER, SPRITE, BLITTER, as well as the new AGA chipset and programming of the PICASSO II video card.
On disk 1, the topics are: 68000, copper, playfields, and sprites.
The blitter, AGA, and the rest are on disks 2 and 3, not completely finished.

Regarding the distribution and copying of this course, you should know that it is GiftWare/Shareware and not strictly public domain.
By this, I mean that you can copy this course to your friends without problems, as long as you don't SELL it for money, since the rights to this course belong to the author, that is me, and not to the first cunning person who wants to speculate on the work of others. On the other hand, if you can copy and distribute it AT THE COST OF BLANK DISKS ONLY, you must also remember that if you successfully follow the various lessons, managing to program something, you have benefited from my work, so you MUST thank me in some way, especially if you become the richest programmers in the world (well, in case...). This gratitude is quantifiable at your pleasure, I prefer 10,000 bills.
The possible influx of little gifts or, better, vile money, would encourage me to continue the hobby of Amiga programming, and also to make new chapters of the course. The address is:

        Fabio Ciucci
        Via S.Leonardo, 13
        55100 LUCCA

You would also do me a great favor if you copied this disk 1 of the course to all your friends, even if you personally are not interested, because you will give someone else the opportunity to have it and learn to program.
I decided to write an ASM (assembler) course because 10,000 people asked me for it, and since I do it for fun, I wrote it in a very questionable manner, but, in my opinion, it will be clearer to beginners who, once they start to understand, can continue more thoroughly. Those who are already experienced in ASM will find the lessons amusing, maybe they will find some inaccuracies, so I advise them to consult the example listings directly: this course is for those starting from scratch. In fact, from my personal experience and from what the aspiring "CODERS" (in jargon, BAD programmers) tell me, the problem is precisely understanding everything and making the first two or three small programs, after which you become able to continue on your own. So, I propose to teach how to make balls bounce on the screen or how to make a text bounce to those who don't even know what a 68000 is. If then these people want to become game programmers and join TEAM 17, they just need to keep going.

TO LEARN HOW TO PROGRAM A GAME LIKE GODS OR PROJECT X, OR ANY GAME THAT ISN'T A FLIGHT SIMULATOR OR A 3D ONE, IN SHORT, A GAME THAT DOESN'T INVOLVE ROTATING CUBES, SINUSOIDAL TUNNELS, PERSPECTIVE DISTORTIONS, FRACTALS, OR TEXTURE MAPPING, I ASSURE YOU THAT HAVING THE MATHEMATICAL KNOWLEDGE OF A MIDDLE SCHOOL STUDENT IS SUFFICIENT.

With this, I want to dispel the idea from everyone's head that Amiga assembler programming is full of mathematics. I BELIEVE INSTEAD THAT IT HAS NOTHING TO DO WITH IT.
If you intend to make a math program, you must know mathematics, just as if you want to make a soccer game, you must know soccer.
The important thing is to know how the Amiga works, its processor (in the case of the Amiga, a Motorola 68000), and its custom chips (those dedicated to graphics and sound).
Personally, I attended high school at the Art Institute of my city, and I learned to do little things in ASM already when I was in middle school, so just use the time the Amiga is on, instead of playing with it: there's no need to attend the computer science faculty at university, where they certainly don't teach you how to program games or demos on the Amiga!!!

But why learn to program games or demos? And what are demos?
Well, everyone knows what games are, so it is assumed that anyone who wants to learn to program them is tired of seeing games that are not as they would like, and they want to make "THEIR OWN", as they want it, pixel by pixel.
As for demos, however, a brief explanation is needed.
Demo stands for "demonstration", that is, a graphical demonstration.
Demonstration of what?
Of the power of the Amiga and the skill of the programmers, of course.
However, there is something more: THE SCENE.
Not the theater one, but the "AMIGA SCENE" (in English, the official language of the scene itself). Imagine the music scene: there are various groups with singers, drummers, etc. For the Amiga, instead, we find various groups with CODERS (programmers), GFX ARTISTS (graphic artists), MUSICIANS (musicians), who instead of making a "VIDEO" like the groups in the music scene do as their contribution, they make a "DEMO", which is added to others made by other groups at different times and places. Then there are the "SWAPPERS" and "TRADERS" who are respectively those who exchange and distribute the demos by mail or modem... they don't produce anything, but they have an importance in the scene because something that doesn't circulate is as if it doesn't exist. On the other hand, they aspire to become CODERS, GRAPHIC ARTISTS, or MUSICIANS, to contribute to making a DEMO, rather than exchanging others' works.
There are many groups in the "Amiga Scene", which have members all over the world, especially in Europe. Some names of the most famous groups are ANDROMEDA, BALANCE, COMPLEX, ESSENCE, FAIRLIGHT, FREEZERS, MELON DEZIGN, POLKA BROTHERS, PYGMY PROJECTS, RAM JAM, SANITY, SPACEBALLS...
Note that each member of the scene goes by a pseudonym, called a "handle". In short, a stage name: for example, two coders from ANDROMEDA call themselves "Dr.Jeckyll" and "Mr.Hyde", one from the FREEZERS calls himself "Sputnik", then others from various groups are: Hannibal, Dan, Paradroid, Dak, Wayne Mendoza, Performer, Bannasoft, Laxity, Vention, Psyonic, Slammer, Tron, Mr. Pet, Chaos, Lone Starr, Dr. Skull, Tsunami, Dweezil.....
The full name is indicated by the handle followed by the group of membership, for example CHAOS/SANITY, DWEEZIL/STELLAR, DAK/MAD ELKS, and so on.
For the scene, I am "RANDY/RAM JAM", but obviously Fabio Ciucci for those who would remain perplexed, not knowing the subject.
The scene organizes PARTIES, kind of gathering parties, where groups bring their demo, and there are competitions with votes and prizes, even in the millions for the winners.
Some demo coders then move on to make games, since the topic is always the same. For example, the programmer of BANSHEE is HANNIBAL/LEMON., the one of ELFMANIA is SAVIOUR/COMPLEX, those of STARDUST are DESTOP/CNCD and SCY/CNCD, and the list could go on...
However, in disk 2, there is a lesson solely about the SCENE.

Returning to assembler programming, whether you want to make demos or games, I advise you not to start learning by studying the listings of 3D routines (routine = part of a listing or program), because they are the most complex, which I myself find hard to digest, not because of the programming itself but because of the mathematical formulas they contain.
But be careful! You must not even think that if mathematics is not needed, knowledge of electronics is required or that it is necessary to study Amiga's electrical diagrams!!! That is only necessary if you want to make a program to manage a graphics card or a video digitizer or similar.
I assure you that you can, for example, display a figure on the screen or play music without knowing where the wires pass!!!
I know people who learned assembler at 12 and others who learned it at 30 or 40, without knowing mathematics well and without knowing English.
So, age is not an acceptable excuse not to try!
YES! BECAUSE YOU SHOULD ALSO GET IT OUT OF YOUR HEAD THAT KNOWLEDGE OF ENGLISH IS ESSENTIAL!
I must admit, however, that knowledge of English can make things easier because ASM commands are abbreviations of English words, like SUB and ADD which mean SUBTRACT and ADD.
Knowledge of Workbench and AmigaDOS will not be useful for programming itself, as the computer actually works very differently. I would say, in simpler terms, that these "overstructures" are the operating system, localized in the kickstart chip, without which the screen prompting to insert the disk would not even appear at startup. The windows you see and move are the result of thousands of lines of ASM code contained in the kickstart, in fact, just look at the difference in windows between kick 1.3 and kick 2.0, which are not due to the difference in the disks inserted, but to the differences in the kick itself.
If you want to make programs like DeLuxe Paint, Home Management, word processors, or any utility for workbench that opens its little windows where you select the gadgets and drop-down menus, I recommend learning the C language instead of ASM, as it is more suitable and once learned, you can easily convert your listings to the MS-DOS and WINDOWS environment, in case you want to abandon the Amiga.
If instead, you are fascinated by graphic demos with bouncing balls and metallic texts and dream of programming games like AGONY, LIONHEART, SHADOW OF THE BEAST, TURRICAN, APYDIA, PROJECT X, SUPERFROG, ZOOL, GODS, CHAOS ENGINE, XENON II, LOTUS ESPRIT, and let's even include SENSIBLE SOCCER, it is clear that they can only be done in PURE ASSEMBLER!!! and do not require particular knowledge of mathematics: basic additions, subtractions, multiplications, and divisions are enough, and some tables of SINE and COSINE to make, for example, balls that fall with a parabolic trajectory, or however following a curve: these tables are nothing more than a series of numbers in memory like 1,2,3,5,8,10,13,15,18,23 which are, for example, the progression of the horizontal position and another series of numbers that are the progression of the vertical position; these series of "tables" or SINUSTAB, that is, a series of numbers that define the coordinates of a curve, can be built with a specific command, the CS, present in the ASMONE, the assembler, even without knowing exactly trigonometry, it may be enough to know the parameters to pass and do some tests. There are many of these SINUSTAB or TABLES in games and demos, as many undulating movements are not calculated entirely on the spot. If, instead, you dream of making ADVENTURE games like MONKEY ISLAND, or managerial games, where only still graphic screens appear with some little character moving slowly inside, where the game consists of selecting objects or texts with the mouse, then you can also use the C language because the game could be easily converted for PC, where you could make a lot of money. After all, PC C is taught in scientific schools, and very well in computer science universities, and they will make the money.

NOTE: Knowing Amiga assembler can be useful if you later switch to programming another type of computer with the same microprocessor, namely the Motorola 68000, which, for example, is used by computers such as Apple Macintosh and Atari ST.
These computers, however, have different operating systems (different from Amiga's kickstart) and different chips dedicated to graphics and sound, so you will need to know the 68000 instructions, but not those of the Amiga operating system and its graphics chips; you will have to learn from scratch; furthermore, even with languages like C, you will have to learn the new operating system.
For example, if you use the C language and make a program for Workbench that opens windows and perhaps draws little mountains, in case you bought a PC MSDOS and wanted to remake it on WINDOWS, the parts of your program concerning the calculations to make the little mountains and the general structure could be reused, but all the parts concerning the opening of the Workbench windows and its selection gadgets you would have to throw away and replace with the instructions for Windows, and I assure you that learning another operating system and converting a program costs months or years.
NOTE: A program written in 68000 assembler works very well on other more powerful processors, provided you keep a few things in mind.

If you are still reading, it means you are undeterred. So I complete the list of assembler utilities... (the language itself is called ASSEMBLY, the program that compiles it is called ASSEMBLER, but it is common usage to also call the language ASSEMBLER). First of all, assembler remains the fastest language, especially if you know it well, and the same thing done with another language will always be slower than one done in assembler.
Then it also remains the only means to create special GRAPHIC effects, never seen before: you can obtain special effects even with a titler, but you can ONLY make those defined by the program. In fact, it is not difficult to discover which program was used to make a titling or a special effect; the same goes for DEMO MAKERs, of which the best is the TRSI DEMOMAKER, which has interesting effects, but now even children recognize something made with a demomaker because there is always the golden writing above and below and in the middle or the balls or the stars... AND THAT'S IT!!! you can't take it anymore! However, by learning to program in assembler, you can invent effects never seen before, because you are not limited to choosing from twenty effects ready for use that other thousands of people have used, filling private television networks and disks.
To give you an idea of the infinite variety of things you can invent in assembler, I can mention the SPACEBALLS "state of the art" DEMO, one of the most famous, which is not difficult to program and has amazed for the stylized figures of women dancing amidst special effects;

If a programmer has more patience, he can even program a game, first to play it, for the pleasure of making the game of dreams, to experiment with the real limits of the Amiga, to see how many little men he can move without slowing down the screen, then there is nothing wrong with trying to make a commercial game, which also requires the collaboration of graphic designers and musicians, as well as all the part related to the commercialization which often rewards more the publicity made for the game than its actual validity, except in cases where the validity is so much so that success comes anyway. Why not start making a game for CD32?? Just make an AGA game that utilizes the 600MB capacity of the CD: for example, a game where the background is a "FILM" loaded in real-time, on which to rotate a RAMBO shoot-'em-up or a spaceship. The difficulty does not lie in learning the new AGA chipset, nor in adapting for CD, in fact the AGA chipset is very similar to the normal one, just learn a few new registers, and the processor works the same way, while as for the CD management, it is even easier because you just have to study the 2 disks of the "CD 32 DEVELOPER KIT" that circulates among programmers. Therefore, assembler on the threshold of 2000 can still be at the forefront, obviously for certain tasks in particular, and if the technology of 2000 will all be on CD, as those who buy the PC to play CD games or often to see naked women hope, given that CDs on the PC MSDOS are mostly sexy slideshows, even the Amiga will have its software on CD, which could be developed by some guy who one day began his adventure by reading a certain programming course.... Knowing how everything works, you can also understand how certain programs or games work and you can modify some parts of it: for example, you can understand why a game or a program does not work on the new Amiga models and you can modify it to make it work, you can make certain modifications to the programs, for example, I modified a utility so that it used virtual memory on disk on the Amiga 4000, other times I sped up some PD programs, of which I "stole" and sped up the most important parts. Finally, you can make so-called trainers, infinite lives, that is, you find the parts of the code that subtract a life from poor PLAYER 1 and you modify everything, maybe increasing the lives when you're killed... to see and understand how a game or a program works, however, it is necessary to REALLY know ASM and have an L.M monitor or better an ACTION REPLAY cartridge (the L.M. monitor is a utility that allows you to disassemble, that is, to view the instructions present in a memory section, and if you find out where in memory are the instructions that remove a life, you can modify everything.. L.M stands for Machine Language, i.e., the language of the microprocessor, which is what is produced by the assembler). However, these operations are a difficult thing, and starting by trying to make a blue man turn green in a game is certainly not useful. I've seen many kids wasting their time aimlessly messing around with L.M. monitors and cartridges, trying in vain to do who knows what, changing the text in programs or listings without understanding them, claiming they had made them or made some important modifications. These individuals still don't know how to display an image in assembly language; in slang, these charlatans are called LAMERS.

Let's take stock of the situation: if you're one of those classic eighteen-year-olds, pale and hunched over, with no women in sight, and you're randomly messing around with LM monitors for your poor Amiga's memory, boasting about being a great hacker, then I advise you to put down the monitor and follow me on the right path. I also started in that ridiculous way (at 8 years old though! not at 18!), but then I came to my senses and started reading books without skipping pages. Here's a book that could help you:

THE AMIGA HARDWARE MANUAL, by IHT: This manual explains how the CUSTOM CHIPS work, those that make the graphics and sound of the Amiga, as well as how to drive the DISK DRIVE, etc.
This is indispensable, but to display even a single image you also need to know the 68000, as it is the 68000 that manages the graphics chips. Furthermore, it all remains an abstract thing, a kind of syntactic series of reference tables, and there are no valid examples.
You can still find many examples in my course!!!! If you know English, look for the latest HARDWARE REFERENCE MANUAL, which is updated on the new ECS chips. However, you can do without it for the duration of my course as the main things are there, even on the AGA chips of the Amiga 1200.
Also included in ASMONE is a command, =C, which provides an explanation of all the registers $DFFXXX, both in general and in particular, for example:
=C 100 will give you an explanation of the BLTCON0 register, concerning the graphics resolution, in the same way =C 040 will give you a summary of BLTCON0, BLITTER reg. ($dff040).

Books like ROM KERNEL MANUAL and PROGRAMMING THE AMIGA volume 1 and 2 from IHT are not useful for direct hardware programming, which I will try to teach in this course, but they are useful for those who want to make programs for the workbench or AmigaDOS, using the operating system contained in the kickstart and workbench disks... intuition window programs therefore, not screens with balls and equalizers or jumping little men among the flames... therefore more useful for C programmers.
I DO NOT RECOMMEND THEM... programming like this is VERY BORING.

NOTE: If, instead of being pale users of LM monitors at random, you are avid researchers of new games to copy and finish, spending hours on the phone asking about the latest news, and the remaining hours copying with XCOPY and playing, maybe always with a trainer just to finish faster, then it's worse than being hunched over with an LM monitor: either stop this rush of research and copying, or you will remain hypertensive people who absolutely do not know why the little men move on the screen, you will never know how to make a game trainer with a menu and everything yourself, and I assure you that when you make a trainer yourself, then you no longer care about finishing the game, but rather about understanding how it works.
This is the difference between the player and the creator of the game, between the subservient and foolish people and the leaders of the regime who command them, making them spend sleepless nights finishing (with or without a trainer) a myriad of games, no matter what, as long as they are many and new, copied with XCOPY (which is by the way the worst copier in the world! use DCOPY instead!).
P.S: Speaking of women, I HAVE NEVER SEEN ANYTHING PROGRAMMED IN ASM BY A WOMAN!!!! If a representative of the female sex is reading this, I think this is all the more reason to be the first!!! A girl who, instead of being interested in gossip about unknown people, or shop windows, starts programming crazy stuff in a skirt, I think would put quite a few little boys who consider themselves intelligent by showing, to the (few) girls they know, how well they move the mouse pointer or the workbench windows, thinking that they don't understand anything anyway and that they can invent that they are geniuses and that they are having connections with NASA, when in fact they don't even know how to format a diskette.

I'll let you know that LESSON2.TXT, which you will read with its example sources after this LESSON1.TXT, is the most DIFFICULT, that FATEFUL, that is, if you manage to pass it the game is done, because already from lesson 3 you make the first special effects with the copper and you will proceed fast like bullets all the way. So I ask you to have the patience to overcome LESSON2.TXT calmly and diligently, without skipping anything.

Now let's analyze the programs used for assembly programming:

-The ASSEMBLER is the program that translates the list made of commands in symbolic format (move, add...) into its binary equivalent (i.e., in bytes).
That is, it translates a text, readable by the programmer, into the real format of the instructions as the processor reads and executes them (a sequence of numbers).
For example, The "RTS" command will be transformed into $4e75, and so on.
This makes programming human, because imagine programming knowing by heart the numbers corresponding to each instruction!!!!
Programming by NUMBERS would mean programming in the real MACHINE LANGUAGE, i.e., LM, but it's useless, it's much better done in ASSEMBLY, using conventional words, called COMMANDS, instead of real numbers.
This resulting binary code is called object code and is directly executable by the computer, in fact the executable file can be saved, or the program can be tested.
Remember that hexadecimal numbering is also used in assembly!
Hexadecimal numbers are those preceded by $, and are in base 16, as we will explain, and can also contain the letters ABCDEF, as in $4e75.
It must be kept in mind that if the listing has "grammatical" errors, they are communicated to us by the assembler, in fact there are precise rules to follow: for example, LABELS must start at the beginning of the line, i.e., they must not be preceded by spaces, and must end with a colon (:). For example, a correct LABEL is

PIPPO:

In fact, the name is given at will, and PIPPO is fine, because it does not contain symbols like = + - etc., it does not have spaces preceding it, and it ends with :.
The labels are names given here and there in the listing to things, and they are used to indicate those things during the program, if for example you name PIPPO: to a certain series of instructions, when in the program we say that PIPPO must be executed, the instructions under PIPPO will be executed, in the same way we can put a label on a figure or a music; the label therefore represents the memory address where it is located, like the names of places represent the position of those places! If I want to go to Australia, I will see a beautiful label AUSTRALIA: above it. Remember, however, that LABELS are for us to orient ourselves, but when the assembler transforms everything, in the object code there are no labels, only the numbers corresponding to the instructions.

Then there are the instructions, which instead must ALWAYS be preceded by spaces, preferably by a TAB (which makes 8 spaces at once, it's the key above CTRL), and followed by the operands, for example:

PIPPO:
        MOVE.L $10,$20

In this case MOVE.L is the instruction, while the first operand is $10 and the second is $20. Some instructions require only one operand and others none, for example:

        CLR.L $10

Requires only one operand. Instructions like RTS do not require operands.
Finally, there can be a comment, useful to remind us what is being done with the instructions: the comment can be written after a semicolon (;).

PIPPO:                      ; LABEL, representing the address of MOVE.L
        MOVE.L $10,$20      ; instruction with 2 operands
        CLR.L $10           ; instruction with 1 operand
        RTS                 ; instruction without operands

Comments are ignored during assembly, so you can write anything, as long as it is after the ;.
This is the grammar. By following these simple rules, the program is assembled. Then whether it does what it's supposed to do or not depends on you!!!

-An EDITOR instead is a program used to write or modify texts, in our case to write listings, which are nothing but texts, made of keywords (move, add...) and comments by the programmer (placed after the ;).
The most powerful editors can search, latch onto, and replace characters.
Usually assembly listings are given a name ending with .ASM or .S, I personally prefer .S, in fact those in the course end in .S, while the texts to read end in .TXT, but the filename obviously doesn't matter to the assembler, which loads it anyway.

-A MONITOR in this case should not be understood as the screen on which you see the images of the Amiga, but another program that allows you to see the contents of memory, for example, what number is at address $100, and so on. Usually MONITORS also have a DISASSEMBLER, which is the opposite of the ASSEMBLER, which allows us to see memory as instructions, rather than as numbers, that is, it translates numbers into their respective symbolic commands (move, add...), in order to clarify how it works.
It thus transforms the MACHINE LANGUAGE into ASSEMBLY, that is, it reconstructs the assembly instructions that each number represents, bringing the OBJECT CODE back to the original form used in the listing. To take the example
used for the assembler, it transforms $4e75 into "RTS".

-A DEBUGGER is used to test the program instruction by instruction, displaying the effects of the instructions each time, and can indicate the cause of the program malfunction. Thus, it allows the program to be executed in pieces, that is, to define until when to execute it, to check the situation, and then resume execution, to find every error.
In fact, BUG means ERROR, in jargon; in English it means ANNOYING INSECT, indeed errors are usually difficult to find in the program; with the debugger you can check where the irregularity occurs.

Sometimes the object code, in order to work effectively on a system must be LINKED with the LINKER, because executable files are not simply the block of instructions you have assembled, but they have parts that allow it to be loaded into memory by the operating system.
This applies to .EXE and .COM files in PC MSDOS and executable files of any other operating system, that's why an executable for Amiga is not loaded from an ATARI ST or from a MACINTOSH, which also have a 68000, precisely because the FILE format is different. Amigas in particular have the HUNK, and to transform the object code into a file with HUNK, which can be executed by clicking with the mouse or loading it from the SHELL, it must be linked.
Fortunately, many assemblers have the linker built in, so you don't need to go through this step.

Well, the assembler included in this course, TRASH'M'ONE, has an EDITOR, an ASSEMBLER, a MONITOR/DEBUGGER, and a LINKER!!! That's everything in ONE!!!! it's the PD modified version (i.e., freely copyable?) of Asmone.

Regarding the editor, you can search for a text by pressing simultaneously the right AMIGA key+SHIFT+S or by selecting (RIGHT MOUSE BUTTON) the Search option in the dropdown menu under the "Edit Funct." item; at this point "Search for:" will appear in the upper left corner, where you will have to write the word (or words) to search for. This may be useful for finding the point where you left off reading: for example, if you want to stop here for today, you can mark the line where you left off, in this case line 549 (indicated in the bottom left corner), or you can also find this point in the text by searching for a word, for example "Funct", or "case la 549", or "searching", or whatever you like.

Normally, we should have written our listing with an EDITOR, and saved the listing (called SOURCE) with a name of your choice.
Then we should have loaded the assembler, from which we loaded the listing, assembled (i.e., transformed from text to its equivalent in L.M) and saved the object code.
To test the program, i.e., to check if it works, we should have run it from the assembler, or linked it, making it executable, and then started it from DOS. To go back to modifying it, we should have looked for the editor, reloaded the listing, modified it, saved it, and redone the assembly.
On the PC MSDOS this is what you have to do, in fact I gave up programming with it, while on the Amiga with multitasking you can load together the EDITOR, the ASSEMBLER etc. As if that weren't enough, someone invented the legendary SEKA, similar to the current ASMONE, which has an editor, assembler, and monitor together. With evolution, we arrived at the MASTERSEKA, then the ASMONE, and finally the many modified versions of ASMONE by various enthusiast programmers. The two most fervent modifiers (good ones!!) are TFA, who made the TFA ASMONE, and DEFTRONIC, who made this TRASH'M'ONE. I chose Deftronic's because it has fewer BUGs, indeed, since these ASMONEs are often modified at best, they often assemble with glitches or suddenly crash, but we certainly can't complain to them as they enjoy adding options without making a dime!

The end result is that you can write your listing, then by pressing ESC you switch to the assembler/monitor, from which you can assemble (with "A"), or view the contents of memory, both as numbers and as disassembled instructions, you can verify the program's operation, and finally save the executable FILE directly with "WO".
To avoid confusion, consider that saving the listing, that is the SOURCE, which is a TEXT, is one thing, while saving the executable, which is a PROGRAM made of instructions in EXECUTABLE FILE format, is another.
The source can also be written with another editor, like CED, and then you can load it from ASMONE. Similarly, a text made with ASMONE can be loaded from an editor. So, ASMONE's editor is not just a normal EDITOR inserted in an assembler, with which you can write even a letter to mom, or edit the STARTUP-SEQUENCE of a disk (For those who don't know what it is, please read the AmigaDos manual!).

Therefore, I will proceed by clarifying and explaining in my own way how the computer works, to avoid misunderstandings.

What organizes everything is the 68000 microprocessor, the CPU, that is Central Processing Unit, in short, the Boss... The processor executes instructions, in fact, it has a set of very specific instructions that it can execute, and it executes them one after the other (sequentially), unless in its path it finds the instruction to jump to execute further ahead or further back, or to perform a certain number of loops. For example, I mention some instructions: MOVE, which means "copy a value from one place to another", for example, "move $10,$20" moves what is in $10 to location $20, or CLR, which means CLEAR: "clr $10" clears location $10... (By LOCATION I mean a point in memory accessible by the processor)

By the way! The processor operates on memory! Let's make a map:

When the instructions operate with addresses less than $200000, we are operating in CHIP RAM, that is: from $000000 to $80000 there are the first 512k of CHIP, those of the old a500 or a2000, while if the RAM continues up to $100000 it means that there is 1 MB of chip RAM, like in a500+, a600 or the new expanded a2000, if the memory CHIP instead is 2MB, like in a1200 or in expanded a500+ or a600, for example, the chip goes from $000000 to $200000. In short, when the processor works on addresses less than $200000 we are in CHIP RAM, for example:

        CLR.L	$30000
        MOVE.L	$150000,$1a0000

These are instructions that operate on CHIP RAM.

When instead they operate on addresses from $200000 onwards, we are in FAST RAM, for example, an old a500 with 1MB of memory, divided into 512k of CHIP and 512k of FAST has the memory divided into 2 parts:

1)      from $000000 to $80000 ; the first 512k of CHIP RAM

2)      from $c00000 to $c80000 ; 512k of FAST RAM.

You can check with utilities like SYSINFO the memory blocks you have.

Then there are special memory areas, like those of the Kickstart ROM, usually from $fc0000 for kick 1.2 and 1.3 or $f80000 for kick 2.0 or 3.0. Unlike RAM, ROM cannot be overwritten, it can only be read, and it does not get erased when the computer is turned off.

An extremely important address is $dff000, as when the instructions operate on addresses ranging from $dff000 to $dff1fe we activate the CUSTOM chips for graphics and sound, in fact, to activate the graphics, you need to put the right values ​​in these addresses $dffxxx, also called REGISTERS, precisely because each one has a function: try doing it from the command line (by pressing ESC you switch between the Editor and the commands) the command "=C", and you will see a summary of those registers, with the number, in which 000 stands for $dff000 and 100 stands for $dff100, and the name, for example $dff006 is VHPOSR, while $dff100 is BPLCON0. These addresses can only be read or written, for example, $dff006 can only be read, and $dff100 can only be written. You will notice a W or an R between the number and the name: those with a W are those that can only be written (WRITE), those with an R can only be read (READ). Some are S (strobe) or ER (EarlyRead), we will talk about them later when we use them.

Other special addresses are found in the area $bfexxx, that is from $bfe001 to $bfef01: these are addresses related to the CIAA chip, which takes care of various things like acting as a timer, that is as a stopwatch, and controlling the
ports like the parallel port (printer port). Similar tasks are performed by the CIAB, connected to the addresses $bfdxxx.

What you need to remember in practice is that when you see an address of the type $dffxxx or $bfdxxx or $bfexxx, we are operating on a CUSTOM register, causing things like changing the colors of the screen, or checking joystick or mouse movements, or something else.

As for RAM memory, both CHIP and FAST, you won't be interested to know at what address each instruction is located because the assembler, as you know, allows us to use LABELS instead of addresses: we will only put them where necessary, then ASMONE will put the real addresses in place of the labels. We can see later at what address our instructions ended up, if we're interested.

Let's continue with examples of instructions:
There are commands like ADD and SUB, which mean ADD and SUBTRACT, for example, SUB #10,ENERGY will subtract 10 from the energy value; there are multiplications and divisions with MULS,MULU,DIVS and DIVU, and logical operations OR, AND, NOT, and others. JMP means JUMP, that is jump to execute at a certain location (example JMP $40000), JSR instead means execute a routine at a given location until you find an RTS, that is "return, the routine is finished", and execution will continue after the JSR; BRA does the same thing as JSR and BSR does like JSR. TST means TEST against zero, that is, it checks if a given location or register is equal to zero; this instruction or the instruction CMP, that is COMPARE something with something else, is usually followed by a conditional jump: BEQ and BNE for example, which mean BEQ= Jump to a certain location if the condition is true (BRANCH IF EQUAL) BNE= Jump if it's not true (BRANCH IF NOT EQUAL). In this way, various branches are created; let's make a stupid example:

Main:
 BSR BELLS              ; BSR jumps below the BELLS label, then
                        ; returns here to execute BSR waitmouse
 BSR waitmouse          ; Waits for the MOUSE to be clicked
 BSR PAVAROTTI
 RTS    ; returns to asmone or workbench

waitmouse:
 checks if the mouse button is clicked
 if it's not clicked go to waitmouse, that is, keep going until
 the mouse is clicked. (in this case you put a "BNE waitmouse")
 RTS        ; end of waitmouse subroutine, returns below the BSR

BELLS:
 dingdong   ; a routine that plays dingdong
 RTS

PAVAROTTI:
 AAAAAHHHHHHHHH ; a routine that makes Pavarotti sing
 RTS

 END        ; Indicates the end of the listing, you can also omit it.

(what is written below the END is not read or assembled)

so, by running this hypothetical program, you can say that "Main" is the main routine, precisely, that calls 3 routines (parts of the program to which gets a name, for example, PAVAROTTI) sequentially: at the beginning, the processor would jump to BELLS: and play the bells, then it finds an RTS and returns to BSR BELLS, where it finds another BSR that takes it to "waitmouse:" which is a routine that runs a loop until the mouse button is pressed... the processor checks
billions of times if the mouse is pressed, and if it's not, it keeps checking endlessly; when the mouse is clicked, the situation changes, because it exits the infinite loop WAITMOUSE, and it reaches its RTS, which means the exit, returning to MAIN under the "bsr waitmouse" that we passed (the processor always executes the next instruction, i.e., below, and even when returning from a BSR, i.e., from the execution of certain instructions placed elsewhere) and finds another BSR that leads it to make Pavarotti sing.
Finally, back from Pavarotti's concert, it finds an RTS, which takes it out of MAIN and then returns to asmone or workbench: THE PROGRAM is finished.

Now I'll explain better how the processor moves between the various instructions:
In the case of "BEQ label", we can talk about branching, in fact, at this point you can take 2 paths: imagine just a tree, one of those dry ones without leaves, an ancient oak, with a knotty trunk, which at a certain point splits into 2 branches, then each of these 2 branches splits into 2, and so on.
when we get to beq it's as if we were an ant that started from the beginning of the program, i.e., from the base of the tree, where our START anthill is:, and we arrived at the first BRANCH: at this point, we either choose to continue on the right branch or the left one. This choice the 68000 makes it based on the result of the condition, whether it's a CMP or a TST:

START:      ; anthill in the grass
...
...
    TST.B LABEL30       ; Is the byte of LABEL30 = 0??? (example condition)
    BEQ RIGHTBRANCH     ; if yes, then jump to RIGHTBRANCH
    ....                ; it's not =0, so we execute the LEFTBRANCH
                        ; (it means the byte is a number from $01 to $FF)
    .... (Instructions of the LEFTBRANCH)
    rts Fine, we exit: we have traveled the LEFTBRANCH and not the RIGHT one

RIGHTBRANCH:
    ... (Instructions of the RIGHTBRANCH)
    ...
    rts Fine, we have traveled the RIGHTBRANCH and not the LEFT one

In this case, a TST condition (compares with 0) and a CMP condition (compares the first operand with the second) followed by a BEQ (if yes, jump to...) or BNE (if no, jump to...), serve to choose whether to execute a certain series of instructions or another one, to take one path or another.
We have already used BNE to make a loop where instead a certain number of instructions are executed repeatedly until the condition is true, for example, the loop that waits for the mouse to be clicked.
The Loop can be compared, instead of an ant climbing a tree, to a ROBOT that has the patience to do even a billion times the same thing without getting tired or going on strike, for example:

GO TO THE KITCHEN, CHECK IF THE CAKE IS BAKED, IF IT'S NOT BAKED RETURN TO THE LIVING ROOM
AND GET THE FLEAS OFF THE DOG FOR 30 SECONDS, THEN
GO TO THE KITCHEN, CHECK IF THE CAKE IS BAKED, IF IT'S NOT BAKED RETURN TO THE LIVING ROOM
AND GET THE FLEAS OFF THE DOG FOR 30 SECONDS, THEN
GO TO THE KITCHEN, CHECK IF THE CAKE IS BAKED, IF IT'S NOT BAKED RETURN TO THE LIVING ROOM
AND GET THE FLEAS OFF THE DOG FOR 30 SECONDS, THEN
GO TO THE KITCHEN, CHECK IF THE CAKE IS BAKED, IF IT'S NOT BAKED RETURN TO THE LIVING ROOM
AND GET THE FLEAS OFF THE DOG FOR 30 SECONDS, THEN
GO TO THE KITCHEN, CHECK IF THE CAKE IS BAKED, IF IT'S NOT BAKED RETURN TO THE LIVING ROOM
AND GET THE FLEAS OFF THE DOG FOR 30 SECONDS, THEN...

As you can see, a human being would rebel at doing for the time necessary to bake a cake such a continuous back and forth, but the 68000 doesn't bat an eyelash. When finally the cake is baked, the BEQ is checked, and the ROBOT jumps to the routine TAKEITOUTOFTHEOVENWITHOUTBURNINGYOURSELFANDPUTITONTHETABLE:.

You can infer that with branches here and there, even within more or less large loops, you can create a complicated structure that satisfies any kind of need, just think about the complexity of programs that simulate the development of a city, which depending on thousands of situations simulates the behavior of citizens. All this is possible through branching sometimes interconnected or cyclical among them.

The branches, i.e., the pieces of instructions executed when BEQ or BNE that call them are verified, or simply because they are found during the 68000's journey, are called ROUTINE or SUBROUTINE, i.e., pieces of program made up of a certain number of instructions that perform a given task, in the case of the ROBOT's cycle, the instructions that remove the cake from the oven could be isolated in a single ROUTINE, which could be executed every time it's necessary to remove the cake from the oven.
In fact, the usefulness of ROUTINE and especially isolated SUBROUTINE lies precisely in not having to rewrite every time you need to remove the cake from the oven the same series of instructions, for example.
We can isolate these instructions and set them aside by giving them a name, assigning them a LABEL at the beginning, and deciding their end with the RTS instruction. Let's give a definition to the word SUBROUTINE:

-It is called a subroutine of a block of instructions to which a name has been given, starting with a LABEL, i.e., a name of choice followed by :, and ending with a special return instruction, RTS (ReTurn from Subroutine), and usually it's executed with the BSR instruction, followed by the name of the subroutine; after executing the BSR, the processor will return to execute the instructions below the BSR that made it execute the subroutine itself.
This can be compared to the commander of a submarine, which in this case is the main program, which by giving orders executes subroutines, for example, imagine that the commander has seen an enemy ship through the periscope, at this point he will give a BSR ArmTorpedoes command, i.e., he will order to arm the torpedoes. Until the subroutine that arms the torpedoes is executed it cannot proceed. Once informed that they have been armed, the commander, i.e., the main program, will continue the procedure: that is, giving BSR RIGHT and BSR LEFT to the engine department until the ship is on
the trajectory of the torpedoes; this could be compared to a loop in which there is a CMP SHIP,TORPEDOES followed by a BNE MOVESUBMARINE, i.e.: "the LABEL containing the position of the ship is equal to the content of the LABEL containing the position that the torpedoes will reach?", if not yet (BNE), then move again, i.e., return to the routine that will check if we are more to the right or to the left, and accordingly execute the RIGHT and LEFT subroutines.
This cycle is similar to that of the ROBOT waiting for the cake to be baked, but in this case, instead of waiting for baking, we actively have to reach the exact position, as in the cycle that waits for the MOUSE, we have to press it to stop it.
We were left with the alignment cycle: suddenly the commander gives the order to launch the torpedoes! (BSR FIREONE, BSR FIRETWO).
BOOOOOOOOOOM... It worked... deaths everywhere, floating socks, widows and orphans scattered all over Germany (in movies the Germans always die), a wreck at the bottom of the sea.
RELAX! It was just a successful computer simulation.

If you've entered the processor's logic, the game is on.
Everything you see running on the computer, whether it's a weather forecast program, a demo with cubes and balls, an action game, is made up of pieces of program that are executed cyclically or sequentially, depending on the responses of the various conditions TST, BTST, CMP. So every type of operation and decision, of any order of complexity, is made up of a certain number of simple conditions, considering that each subroutine can be made up of other smaller subroutines, for example, TAKECAKEOUTOFTHEOVEN:

TAKECAKEOUTOFTHEOVEN:
    BSR TurnOffTheOven
    BSR OpenTheOven
    BSR TakeTheCake (it's a robot and won't get burned)
    BSR PlaceTheCakeOnTheTable
    BSR CloseTheOven
    rts

In turn, the sub-subroutines can be made up of other subroutines:

TurnOffTheOven:
    BSR GoToTheSwitch
    BSR TurnItToLeft
    rts

The main utility of subroutines is to make the program clearer, dividing it into logical parts, and the possibility of creating a collection of routines that can be used for other programs, for example, if you have a routine that reads the joystick position you can reuse it in all the games you'll make, with slight modifications if necessary, similarly the routine that plays music, or the one that makes a little man walk on the screen.

This is to give an idea of the continuous execution and wandering according to the true or false conditions of the poor microprocessor.
When hopping around there's an error, for example, it jumps into a zone with poorly loaded data from disk or where the programmer made a mistake, then the mythical GURU MEDITATION appears, or SOFTWARE FAILURE in its unsettling flashing red window.
The rewritable memory (RAM) can be modified, and it's divided into CHIP ram and FAST ram, as already mentioned.
The difference is that the GRAPHICS and SOUNDS must be in CHIP RAM, while the processor instructions can be in both CHIP and FAST.
For example, the old 1.2 or 1.3 Amiga 500 has 512Kb of RAM, half a megabyte, and if expanded it reaches one megabyte of RAM, but the other 512k are FAST, that's why, for example, with DeLuxe Paint you run out of memory sooner with 1MB divided into 512k CHIP and 512k FAST compared to an a500+ which instead has 1MB all CHIP: there's still memory in the old 500, but it's of the FAST type and it's not used to open a new screen, so it says there's no memory. When programming if you try to display graphics placed in FAST, it's chaos, everything except displaying that image. Memory is made up of blocks of various sizes, for example, on an old a500 the first 512k of chip ram go from address $00000 to $80000 and the 512k of expansion from $c00000 to $c80000: the operating system knows where the memory is and automatically loads programs
into empty areas, for example, loading a program from the Workbench or from the CLI or SHELL the data from the floppy disk will be transferred (thanks to the kickstart) in memory, depending on whether CHIP or FAST memory is required, then the processor will jump to the memory point where it loaded (or rather copied from the disk) the program. The user remains unaware of where in memory the program has been placed and where the microprocessor is working.
I said that chip memory in the old 500 goes from $00000 to $80000, the memory is indeed divided into parts, like a street with many little houses each with its address: hence they're called memory addresses or locations (ADDRESS in English): at the beginning of the street there's house 0, which contains one byte, the next house has address 1, which contains another byte, and so on. However, the hexadecimal numbering system is used, i.e., base 16. This is not a problem, because from ASMONE you can convert the number at any time using the "?" command: by typing "?$80000" you'll get 524288 in
decimal, which corresponds to 1024512, i.e., half a Kb or "KAPPA RAM", precisely 1024 bytes, multiplied by 512. $100000 instead is twice as much, i.e., one megabyte... try ?$800002 ("*" meaning "MULTIPLIED"). Hexadecimal numbers are preceded by a dollar sign, as you've seen, decimal numbers are not preceded by anything, binary numbers by a %.
These things are basic: just as for distances there's the meter, the dekameter, and the kilometer, for memory there's the BIT, the BYTE, the WORD, and the LONGWORD. The bit is the smallest part of memory; the BYTE, composed of 8 bits, is a unit that has its address: the processor, that is, can say: move (or rather copy) the byte that is in the little house on "memory street n10" to the little house on "memory street n16", in this case, it has copied the eight bits that were in the byte 10 (i.e., $A in hexadecimal) into byte 16.
To avoid confusion, let's make an unequivocal example: bits can be 0 or 1; in byte 10 the bits were: 00110110, in byte 16 instead 11110010, after the MOVE.B 10,16 the byte 10 remains 00110110, byte 16 becomes 00110110. the .B in the MOVE means that a BYTE is being moved, that is, the smallest part that can be copied.
you can also do a MOVE.W and a MOVE.L, i.e., move a WORD (.w) or a LONGWORD (.L), which are nothing but: 1 word = 2 bytes, one longword = 4 bytes, or 2 words. So if you do a MOVE.W 10,16, byte 10 will be copied into byte 16, byte 11 into byte 17, i.e., a block of 2 bytes is moved. In the case of a MOVE.L, 4 bytes are moved, i.e., in byte 16 byte 10, in 17 the 11, in 18 the 12, in 19 the 13. Let's make a little scheme:

BEFORE THE MOVE.L 10,16 ; 08/09/10/11/12/13/14/15/16/17/18/19/20
				                 C  A  N  E	       G  A  T  T  O

AFTER THE MOVE.L 10,16 ;  08/09/10/11/12/13/14/15/16/17/18/19/20
				                 C  A  N  E	       C  A  N  E  O

If we do MOVE.B 20,14 ;   08/09/10/11/12/13/14/15/16/17/18/19/20
				                 C  A  N  E  O     C  A  N  E  O

In our supposition, the locations 08,09,14,15 were cleared,
while 10-13 and 16-20 had a value, here some letters
for example. let's conclude with a MOVE.W 8,10:

                         ;08/09/10/11/12/13/14/15/16/17/18/19/20
                                     N  E  O     C  A  N  E  O

With 3 instructions we transformed DOG CAT into GO DOG!!!!!
Jokes aside, don't continue reading until the operation of synthetic memory is imprinted in your brain memory!!!!
Play around a bit with move.x, it's good for you!
For example, try turning ANTANI into TANTI NANI with various MOVEs, or SBLINDO into DOBLONI, or RENULOZ into  UZZURELLONE, etc.
Remember that processor INSTRUCTIONS must be at even addresses like 2,4,6... otherwise it's all GURU.
To remove doubts, in memory there's a series of values one after the other, which can be 68000 instructions, or data such as the previously mentioned SINUSTAB, figures, sounds, texts to display... the instructions in memory are not in the form MOVE.B 10,16, that is a DISASSEMBLED version, in memory for example that instruction occupies 10 bytes, and it's: $13,$F9,$00,$00,$00,$0A,$00,$00,$00,$10, where $13f9 means roughly MOVE.B, $0000a is 10 in  exadecimal and $10 is 16 in hexadecimal... likewise, each instruction has its bytes, for example, the NOP instruction, i.e., no operation, which does nothing, in memory is $4e71. I anticipate that besides operating on memory the processor has registers available, called data registers and address registers, which are 16 and each longword long, called a0,a1,a2,a3,a4,a5,a6,a7 the Address regs, d0,d1,d2,d3,d4,d5,d6,d7 the data regs; they're inside the processor and therefore operations between 2 registers are much faster than those between 2 memory addresses, for example, move.l d0,d2 will be faster than move.l $100,$200; therefore it's preferred to perform operations putting numbers in registers rather than in memory, if possible.

As already mentioned, ROM cannot be written, i.e., a MOVE that writes to ROM has no effect: a move to $FC0000 or $f80000 is useless. Only the ROUTINES contained in ROM can be executed. BUT SINCE THE KICK DIFFERS IN EACH VERSION, NEVER SHOULD YOU JUMP DIRECTLY TO THE KICK.
The operating system it's done in such a way that the routines, meaning the individual programs present in the kickstart, can be called in the same way regardless of the kick and wherever it's located in memory: this is done through JSRs, namely JUMP TO SUBROUTINE (Jump to an address, then return and continue from below the JSR), which are fixed but start from the address present in address 4, where the address is always present from which to refer to make the right JSRs to execute the routines of the kickstart. Programs to open Workbench windows or to print characters, to read or write a file on disk must call the routine present in the kickstart ROM CHIP every time, passing for example the filename to load or the dimensions of the window to open; instead, when a game or a demo "JUMPS" the operating system, calls to the kickstart are not made: for example, the well-known XCOPY opens its own screen, and it's clear that it removes multitasking and doesn't have the little windows and right-click menus like operating system programs. Similarly, a game like those mentioned before, like SENSIBLE SOCCER, would work even if after booting the kickstart chip were removed, as no routines are called to open windows or load files: the things that appear on the screen are controlled one by one and the data from the disk is loaded not as DOS files, but as tracks read directly by moving the disk drive heads and giving current to the cable pins or not. Is this difference clear? Among the programs or games that USE the operating system, meaning they continuously call routines in the ROM and maintain multitasking and windows, and the other programs that do not open windows or open them differently from the WorkBench, and cannot be run together with Deluxe Paint, swapping the window or moving it down?? In short, the ROM takes care of interacting with the hardware for us if we ask it to, and it does a certain number of preset things, whereas if we decide to interact with the hardware OURSELVES, we can do everything possible, provided we are capable!!!

So, we will be busy writing code without using the ROM. But then will we only use the microprocessor? and how do we display an image or play music? with MOVEs????
Now the CUSTOM CHIPS come into play!!!
these CHIPS are called PAULA, AGNUS, and DENISE, also there are another 2 CHIPS called CIAA and CIAB. These cunning ones are the ones that make the Amiga sound and make it display all those colors on the screen.
Most of the relevant registers are located at address $dff000 up to $dff1fe, others concerning serial, parallel ports, and disk drives are located in the $bfexxx or $bfdxxx area.
Once you've learned all the 68000 instructions you can build programs as big as houses, but if you move memory around here and there, nothing will be displayed or sounded! with the processor, you have to control these chips; one of the main ones is the BLITTER, which takes care of drawing lines, copying pieces of memory like scrolling or little men around the screen, filling areas (3D solids are drawn and filled with the blitter; the processor takes care of calculating the coordinates of the lines which are then drawn by the blitter).
But what displays everything and determines the colors is the COPPER: for example, $dff180 corresponds to color 0 and $dff182 to color 1, while in $dff006 there's the line where the electronic brush arrived when drawing the screen, which is drawn 50 times per second: these registers are indeed READ ONLY or WRITE ONLY, for example in $dff180 a value can be placed, but you can't read what value is there, the same goes for $dff006, which you can't write to; to change the position of the electronic brush, however, there's a specific register, as with many others. In registers $bfexxx you can control the disk drive or the various ports, including the mouse port: for example, bit 6 of address $bfe001 corresponds to the state of the left mouse button, whether it's pressed or not, and you can check it with the processor and wait for it to be pressed before exiting. And this is the first example of programming that you can analyze by loading LESSON1a.s, the first source of the course, which together includes a loop with the 68000, the use of a $dffxxx register, and a $bfexxx register. (load it into another text buffer as explained below).

A brief mention of how to use the assembler, in this case ASMONE:
At the beginning, you must select whether to allocate CHIP or FAST memory, it's good to select chip memory for the course sources, depending on how much you have, select the number of Kb, at least 250.
To select a directory or drive, use the "v" command, for example, to go to the directory of the lessons, do a "V df0:LESSONS", to go to the directory of the sources, do a nice "V df0:SOURCES", then to read the source or lesson use "R", and select it with the little window.
You can switch with ESC between the editor function and the command line; that is, press ESC and you can scroll or edit the text, press ESC again and return to the command line where you can, for example, ASSEMBLE the listing with "A", then to execute it you must press "J". (JSR!!)
You can also load 10 texts simultaneously, be they sources or lessons, because, when you are in EDIT mode, when you can scroll the text with the cursor and can change it, if you press F2 you will switch listing, and you will go to the second one, which in this case will be empty: if you press F1 again you return to the text loaded before: in this way you can, for example, keep in buffer 1 (i.e., listing 1 callable with F1) Lesson1.TXT, while in buffer 2, selectable with F2, you can load the listing concerning Lesson1, i.e., Lesson1a.s. Later you can put Lesson1 in buffer 1, Lesson2 in buffer 2, in buffer 3,4,5 the listings of Lesson2, and so on, then you can consult the lesson, then by pressing F4 or F5 immediately verify the execution of a listing, or go back to see something from Lesson1 that you don't remember, etc.
NOTE: to scroll page by page use the cursors (arrows) plus SHIFT, i.e., for those who didn't have the C64, the big key above ALT with the arrow.
Let me explain what happens when you do "A": the listing (or source) is in normal text format, and it consists of keywords that are commands or other symbols that the assembler knows... to mark a group of instructions or a "variable", or the beginning of a table, or however to have a reference to a specific point in the listing, you make LABELS or LABELS, which must not have spaces from the beginning of the edge, and must end with: (TWO POINTS). The name of the label is chosen, but you must not give a name that is the same as a 68000 command!!! for example:

WAITMOUSE:              ; the label
    btst #6,$bfe001     ; left button pressed?
    bne.s WAITMOUSE     ; if not, return to WAITMOUSE (repeat btst)
    rts                 ; Exit

I remind you that the commands must have a spacing, in this case, I used the TAB (The key above CTRL and CAPS LOCK), which makes 8 spaces with a single stroke... Notice that the final: (colon) must not be put at the name of the label (or tag) when it's recalled, but only to itself.
So, once the source is edited, it's ASSEMBLED with "A"; this operation makes ASMONE read the text and transform it into code, i.e., into bytes that will be read by the 68000 and executed as instructions.
Once assembled, the said code is at a point in memory that can be seen with "=R", and with the "J" command the processor jumps to that point in memory and executes our program. If ASMONE finds an error in the listing, it doesn't assemble everything until the error is corrected.

The course sources work with other assemblers like DEVPAC 3 and MASTERSEKA, with all kickstarts and all Amigas, including AGA models like the 1200 or the 4000.

If you have verified the functionality of Lesson1a.s, load the file LESSON2.TXT into another text buffer (buffer F3, for example) with "R".

If you encounter a memory shortage when switching buffers, it means you allocated too much memory at the beginning (at the ALLOCATE message), and none is left for the RAM DISK. Next time, allocate less.